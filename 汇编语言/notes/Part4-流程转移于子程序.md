# **第九章 转移指令的原理**

本章主要讲如何控制CPU执行指令的顺序。

可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括的降，转移指令就是可以控制CPU执行内存中某处代码的指令。

8086CPU的转移指令有以下几类。

- 只修改IP时，称为**段内转移**，比如：jum ax。
- 同时修改CS和IP时，称为**段间转移**，比如：jmp 1000:0。

由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。

- 短转移IP的修改范围为-128~127。
- 近转移IP的修改范围为-32768~32767。

8086CPU的转移指令分为以下几类。

- 无条件转移指令（如jmp）
- 条件转移指令
- 循环指令（如loop）
- 过程
- 中断

这些转移指令的前提条件可能不同，但转移的基本原理是相同的。

### **9.1 操作符 offset**

操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。

### **9.2 jmp 指令**

jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP。

jmp指令要给出两种信息：

（1）转移的目的地址
（2）转移的距离（段间转移、段内短转移、段内近转移）

下面几节将对jmp指令进行详细的介绍。

### **9.3 依据位移进行转移的jmp指令**

> jmp short 标号

实现的是段内短转移，执行后： （IP） = （IP）+ 8位位移。

（1）8位位移=标号处的地址-jmp指令后第一个字节的地址；
（2）short指明此处的位移为8位位移；
（3）8位位移的范围为-128~127，用补码表示；
（4）8位位移由编译程序在编译时算出。

> jmp near ptr 标号

实现的是段内近转移，执行后：（IP） = （IP） + 16位位移。

（1）16位位移=标号处的地址-jmp指令后第一个字节的地址；
（2）near ptr 指明此处的位移为16位位移，进行的是段内近转移； （3）16位位移的范围为-32768~32767，用补码表示；
（4）16位位移由编译程序在编译时算出。

### **9.4 转移的目的地址在指令中的jmp指令**

> jmp far ptr 标号

实现的是段间转移，又称为远转移。功能如下：
（CS）=标号所在段的段地址；（IP）=标号所在段中的偏移地址。

far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。

该指令与上节学习的段内转移明显不同的是：
段内转移机器指令携带的是位移，段间转移机器指令携带的是目的地址。

### **9.5 转移地址在寄存器中的jmp指令**

> jmp 16位的reg

该指令实现的功能为：（IP）= （16位的reg）

### **9.6 转移地址在内存中的jmp指令**

> jmp word ptr 内存单元地址（段内转移）

功能：从内存单元地址处开始存放一个字，是转移的目的偏移地址。

内存单元地址可以用之前学过的任一寻址方式给出。

> jmp dword ptr 内存单元地址（段间转移）

功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的的偏移地址。

### **9.7 jcxz 指令**

> jcxz 标号

功能：如果（cx）=0，则转移到标号处执行。如果（cx）≠ 0，则程序继续向下执行。

jcxz指令为有条件转递指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为：-128~127。

### **9.8 loop指令**

> loop 标号

功能：（cx）=（cx）-1，如果（cx）≠ 0，则转移到标号处执行。

### **9.9 根据位移进行转移的意义**

方便了程序段在内存中的浮动装配。

### **9.10 编译器对转移位移超界的检测**

根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。

------

# **第十章 CALL和RET指令**

> call和ret都是转移指令，它们都修改IP，或同时修改CS和IP。它们经常被共同用来实现子程序的设计。

### **10.1 ret 和 retf**

这个两个指令可以理解为高级语言中的return关键字，表示程序返回。

ret 用栈中的数据，修改IP的内容，从而实现近转移；
retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。

CPU执行ret指令时，进行下面两步操作：

（1）(IP) = ((SS)*16+(SP))
（2）(sp) = (sp)+2

以上步骤相当于进行：

> pop IP

CPU执行retf指令时，进行下面4步操作：

（1）(IP) = ((SS)*16+(SP))
（2）(sp) = (sp)+2
（3）(CS) = ((SS)*16+(SP))
（4）(sp) = (sp)+2

以上步骤相当于进行：

> pop IP pop CS

### **10.2 call 指令**

call指令可以理解为高级语言中的方法（函数）调用功能。

CPU指令call指令时，进行两步操作：

（1）将当前的IP或CS和IP压入栈中。 （保存现场） （2）转移。

call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。

### **10.3 依据位移进行转移的call指令**

指令格式：

> call 标号

CPU执行该指令时相当于进行：

> push IP jmp near ptr 标号

### **10.4 转移的目的地址在指令中的call指令**

指令格式：

> call far ptr 标号

CPU执行该指令时相当于进行：

> push CS push IP jmp far ptr 标号

该指令编译的机器指令中包含了转移的目的地址。包括段地址CS的值及偏移地址IP的值。

### **10.5 转移地址在寄存器中的call指令**

指令格式：

> call 16位reg

CPU执行该指令时相当于进行：

> push IP jmp 16位reg

### **10.6 转移地址在内存中的call指令**

转移地址在内存中的call指令有两种格式。

（1）第一种指令格式：

> call word ptr 内存单元地址

CPU执行该指令时相当于进行：

> push IP jmp word ptr 内存单元地址

（2）第二种指令格式:

> call dword ptr 内存单元地址

CPU执行该指令时相当于进行：

> push CS push IP jmp dword ptr 内存单元地址

### **10.7 call和ret的配合使用**

call和ret的配合使用可以用来实现子程序的机制。call指令在转去执行子程序之前，会将当前指令下一条指令的位置保持在栈中，当子程序执行ret或retf指令后，会用栈中的数据设置ip或cs和ip的值，从而转到call指令后面的代码处继续执行。

### **10.8 mul指令**

（1）两个相乘的数：练歌相乘的数，要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；如果是16位，一个默认放在AX中，另一个放在16位reg或内存字单元中。

（2）结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认在DX中存放，低位在AX中存放。

### **10.9 模块化程序设计**

> 现实问题比较复杂，对现实问题进行分析时，把它转化为相互联系、不同层次的子问题，是必须的解决方法。

在高级语言中的函数或者方法就是这种思想的体现。在汇编语言中我们将高级语言中的方法或函数称之为子程序。

### **10.10 参数和结果传递的问题**

当我们设计子程序时面临两个问题：

（1）参数存放的位置？
（2）计算结果存放的位置？

实际上，我们可以将参数及结果存放于任何可以存储数据的地方。一般情况下，我们可以将参数存储在寄存器中，也可以存储在普通内存单元中。更一般的做法我们将其存储在栈中进行传递。

### **10.11 寄存器冲突的问题**

寄存器数量是有限的，子程序中使用的寄存器，很可能在主程序中也要使用，造成了寄存器使用上的冲突。解决这个问题的简捷方法是，**在子程序的开始将子程序中所有用到的寄存器中的内容都保存起来，在子程序返回前再恢复。** 可以用栈来保存寄存器中的内容。

栈是临时保存数据的一个比较理想的数据结构。

# **第十一章 标志寄存器**

标志寄存器(Flag Register)是我们8086CPU14个寄存器中最为复杂的一个。其他13个寄存器一般用于存放数据，整个寄存器具有一个含义。而flag寄存器是按位起作用的。

这一章中我们主要学习CF、PF、ZF、SF、OF、DF等标记位，以及其相关部分指令。

### **11.1 ZF标志**

Zero Flag，零标记位。用于记录相关指令执行后，其结果是否为0。如果结果为0，则ZF=1，如果结果非0，则ZF=0。

需要特别注意的是：

> 在8086的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如mov、push、pop等，它们大都是传送指令。

### **11.2 PF标志**

**Parity Flag**，奇偶标记位。它用于记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果1的个数为偶数，则pf=1，如果为奇数，则pf=0。

### **11.3 SF标志**

**Sign Flag**，符号标记位。它用于记录相关指令执行后，其结果是否为负。如果结果为负，则SF=1，如果结果非负，则SF=0。

计算机中通常用补码来表示有符号数，补码在形式上与普通的无符号二进制数据并无差异。也即是说，给定的一个二进制数，我们既可以把它当做有符号数的补码形式，也可以当做一个无符号数。对于计算机来说，无论是无符号数还是有符号数的补码形式，在计算方式上并无差异（补码的符号位同样参与运算）。

SF标志，就是CPU对**有符号数**运算结果的一种记录，它记录数据的正负。在我们将数据当做有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当做无符号数来运算，SF的值则没有意义，虽然相关指令影响了它的值。

### **11.4 CF标志**

**Carry Flag**，进位标志位。一般情况下，在进行**无符号数运算**的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。

### **11.5 OF标志**

**Overflow Flag**，溢出标志位。在进行**有符号数运算**的时候，如果计算结果超出了机器所能表示的范围则发生溢出，此时OF=1。否则，OF=0。

注意区分CF和OF的区别：CF是对无符号数运算有意义的标志位，OF是对有符号数运算有意义的标志位。

### **11.6 adc指令**

adc是带进位加法指令，它利用了CF位上记录的进位值。

指令格式：

> adc 操作对象1，操作对象2

功能：操作对象1=操作对象1+操作对象2+CF

比如指令 adc ax,bx 实现的功能是：（ax）= （ax）+ （bx）+ CF

既然我们已经有了add指令，那为什么还要设计adc指令呢？

设想一下，之前我们使用add指令做加法运算的时候，相加结果都是16位以内，如果和大于16位就会产生误差。adc指令目的就是对任意大的数据进行加法运算。自习观察加法运算可以得到如下规律：

任意大的加法运算都可以分解为多步进行，低位相加，高位相加再加上低位相加产生的进位值，直至所有位都相加完毕。

使用adc指令结合上述规律就可以实现对任意大的数据进行加法运算。

### **11.7 sbb指令**

sbb是带借位减法指令，它利用了CF位上记录的错位值。

指令格式：

> sbb 操作对象1，操作对象2

功能：操作对象1=操作对象1-操作对象2-CF。

sbb指令和adc指令是基于同样的思想设计的两条指令，在应用思路上和adc指令类似。

### **11.8 cmp指令**

cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。

指令格式：

> cmp 操作对象1，操作对象2

功能：计算操作对象 1 - 操作对象 2 但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。

利用 cmp ax, bx 指令对两个无符号数ax和bx进行比较，如果执行后：

- zf = 1，说明 (ax) = (bx)
- zf = 0，说明 (ax) ≠ (bx)
- cf = 1，说明 (ax) < (bx)
- cf = 0，说明 (ax) ≥ (bx)
- cf = 0 并且 zf = 0，说明 (ax) > (bx)
- cf = 1 或 zf = 1，说明 (ax) ≤ (bx)

利用 cmp ah,bh 指令对两个有符号数ah和bh进行比较，由于有符号数的比较较为复杂，主要是考虑到溢出的特殊情景，我们分类讨论：

（1） 如果 sf = 1 并且 of = 0

of = 0 说明没有溢出，并且 sf = 1 说明逻辑上真正的结果为负数。所以 (ah) < (bh)。

（2） 如果 sf = 1 并且 of = 1

of = 1 说明存在溢出，**针对补码求和来说，如果结果非0并且产生溢出，正确的逻辑结果符号与实际的结果符号必然相反。** sf = 1 说明实际结果为负，那么正确的逻辑结果应该为正。所以 (ah) > (bh)。

（3） 如果 sf = 0 并且 of = 1

of = 1 说明存在溢出，**针对补码求和来说，如果结果非0并且产生溢出，正确的逻辑结果符号与实际的结果符号必然相反。** sf = 0说明实际运算结果必然不小于0，因为存在溢出所以实际运算结果必不等于0，所以实际运算结果必然大于0，进而推导出正确的逻辑运算结果必然小于0。所以 (ah) < (bh)。

（4） 如果 sf = 0 并且 of = 0

of = 0 说明没有溢出，并且 sf = 0，说明逻辑上真正的结果为非负数。所以 (ah) ≥ (bh)。

（5） 如果 zf = 1

这种情形比较简单。此时 (ah) = (bh)。

### **11.9 检测比较结果的条件转移指令**

“转移”指的是它能够修改IP，而“条件”指的是它可以根据某种条件，决定是否修改IP。比如，jcxz就是一个条件转移指令，它可以检测cx中的数值，如果 (cx) = 0，就修改IP，否则什么也不做。**所有条件转移指令的位移都是 [-128, 127]（即它们都是短转移）。**

jcxz是根据寄存器cx的值来判断是否转移，除此之外还存在其他条件转移指令，大多数条件转移指令都检测标志寄存器相关标志位，根据检测的结果来决定是否修改IP。

下表列出了常用的根据无符号数的比较结果进行转移的条件转移指令：

| 指令 | 含义         | 检测的相关标志位 | 备注              |
| ---- | ------------ | ---------------- | ----------------- |
| je   | 等于则转移   | zf = 1           | e 表示 equal      |
| jne  | 不等于则转移 | zf = 0           | ne 表示 not eauql |
| jb   | 低于则转移   | cf = 1           | b 表示 below      |
| jnb  | 不低于则转移 | cf = 0           | nb 表示 not blow  |
| ja   | 高于则转移   | cf = 0 且 zf = 0 | a 表示 above      |
| jna  | 不高于则转移 | cf = 1 或 zf = 1 | na 表示 not above |

**注意，条件转移指令通常与cmp指令配合使用。**

### **11.10 DF标志和串传送指令**

Direction Flag，方向标志位。在串传送指令中，控制每次操作后 si、di 的增减。

df = 0 ，每次操作后 si、di 递增；
df = 1 ，每次操作后 si、di 递减。

下面，我们学习几个常见的串传送指令。（写到这里，突然想吃羊肉串了~~）

**movsb指令**

格式：

> movsb

功能：将ds:si指向的内存单元中的字节送入es:di中，并根据标志寄存器df的值，将si和di递增或递减。 **movsw指令**

与 movsb 指令类似，只不过 movsw指令传送的是一个字单元。

**rep 指令**

本人将其翻译为重复指令（repetition）。movsb 和 movsw 进行的是串传送操作中的一个步骤，一般来说，movsb 和 movsw 都配合 rep 配合使用，格式如下：

> rep movsb

功能：根据cx的值来决定是否重复执行 movsb操作。使用汇编语法来描述就是>

> s: movsb loop s

**cld 指令和 std 指令**

cld 指令：将标志寄存器的 df 位置0；
std 指令：将标志寄存器的 df 位置1。

为了方便记忆，可以将 cld 理解为 clear direction 的缩写，将 std 理解为 set direction 的缩写。

### **11.11 pushf 和 popf**

pushf 的功能是将标志寄存器的值压栈，而 popf 是从栈中弹出数据，送入标志寄存器中。

pushf 和 popf 为直接访问标志寄存器提供了一种方法。

### **11.12 标志寄存器在Debug中的表示**

在Debug中，我们使用r命令查看寄存器详情，第二行最后几个双字符字母即是标志寄存器中各标志位的值。

 