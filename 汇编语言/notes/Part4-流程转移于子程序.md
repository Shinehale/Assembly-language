# 第九章 转移指令的原理

- 转移指令

  可以控制`CPU`执行内存中某处代码的指令，或者可以修改`IP`、或者同时修改`CS`和`IP`的指令

  

- 8086CPU的转移行为可以分成一下几类

  - 段内转移

    - 短转移

      修改范围：`-128~127`，就是一个字节的长度

    - 近转移

      修改范围：`-32678~32767`，一个字的长度

  - 段间转移

    - 同时修改`CS`和`IP`



- 操作符`offset`

  功能：取得标号的偏移地址



- `jmp`指令

  `jmp`为无条件转移指令，可以修改`IP`，也可以同时修改`IP`和`CS`

  通常情况下指令需要给出两种信息：

  - 转移的目的地址
  - 转移的距离（段间转移，段内短转移，段内近转移）



- `jmp short 标号`根据位移进行转移`jmp`指令

  `jmp`指令实现的是段内短转移，其对`IP`地址的修改范围为`-128-127`，即最多向前越过128字节，最多向后越过127个字节。

  观察源代码显示的确实是**相对地址**，说明`CPU`在执行`jmp`指令的时候并不需要转移目的的地址

  总结：

  - `jmp short 标号` `<==>` `(IP)=(IP)+8位位移`
  - 其中的八位位移表示的是**标号处地址-`jmp`指令后第一个字节的地址**
  - 八位地址的范围为`-128~127`并且使用补码进行表示
  - 8位地址位移将在**编译**的时候完成计算而得出



- `jmp near ptr 标号`同上述近转移有相同的功能但是它实现的是**段内近转移**

  即它的位移长度用的是**16位**的情况



- `jmp far ptr 标号`实现的是段间转移，又称为**远转移**

  `(CS)`为标号所在段的段地址，`(IP)`为标号在段中的偏移地址

  而`jmp far ptr`指明了指令用标号的段地址和偏移地址修改`CS`和`IP`



- 转移地址在寄存器或者内存中的情况
  - `jmp 16位reg` 功能： `(IP)=(16位的寄存器)`
  - `jmp word ptr 内存地址单元`（段内转移）
    - 功能：从内存单元地址处开始存放一个字，是转移的目的偏移地址
  - `jmp dword ptr 内存地址单元`（段间转移）
    - 功能：从内存单元地址处开始存放两个字，并且**高地址**位存放**目的段地址**，**低地址**存放目的**偏移地址**



- `jcxz`指令

  此指令是有条件转移指令并且，**所有的有条件转移指令都是短转移**。

  即对`IP`的修改范围是`-128-127`

  指令格式：`jcxz 标号` （如果`cx`为0，转移到标号处执行）



- `loop`指令

  `loop`指令是循环指令，并且所有循环指令都是**短转移**

  格式：`loop 标号` `((cx)=(cx)-1)，若(cx)!=0，转移到标号处去`

  

- 转移时注意事项

1. 短转移都会有内存转移范围是`-128-127`的问题，如果超界将报错
2. **不能**存在`jmp 2000:0100`这样的**转移立即数**情况





# 第十章	`CALL`和`RET`指令

- `ret` 和`call`指令都是转移指令，他们都修改`IP`，或同时修改`IP`和`CS`

  `ret`指令用栈中的数据，修改`IP`的内容，从而实现**近转移**

  `retf`指令用战中的数据，修改`CS`和`IP`的内容，从而实现**远转移**

  `CPU`执行`ret`指令的时候相当于:

  ```assembly
  POP IP
  ```

  `CPU`执行`retf`指令的时候相当于：

  ```assembly
  pop IP
  pop CS
  ```



- `call`指令

  `CPU`执行`call`指令的时候，进行两步操作：

  - 将当前的`IP`或`CS`和`IP`压入栈中
  - 转移

  `call`指令**不能实现短转移**



- `call 标号` （将当前的`IP`压栈后，转移到标号处执行指令）

  并且**程序是先将IP移到下一个代码位移之后再`push IP`**

  相当于执行下列：

  1. `push IP`
  2. `jmp near ptr 标号`



- `call far ptr 标号`实现的段间转移

  相当于执行下列代码：

  1. `push cs`
  2. `push IP`
  3. `jmp far ptr 标号`



- 转移地址在寄存器中的`call`指令

  指令格式：`call 16位reg`

  相当于进行：

  ```assembly
  push IP
  jmp 16位reg
  ```

  

- 转移地址在内存中的`call`指令

  包括两种：

  1. `call word ptr 内存单元地址`
  2. `call dword ptr 内存地址单元`



- `call`和`ret`实现子程序控制的框架如下：

```assembly
assume cs:code
code segment
main:	:
		:
		
		call sub1
		:
		:
		mov ax, 4c00h
		int 21h
		
sub1:	:
		:
		call sub2
		:
		:
		ret
		
sub2:	:
		:
		:
		ret
code ends
end main
```



- `mul`指令

  1. 两个相乘的数，要么都是8位，要么都是16位，如果是8位，一个默认在`AL`中，另一个放在8位`reg`或内存字节单元中；如果都是16位，一个默认在`AX`中，另一个存在16位`reg`或内存单元中
  2. 结果：如果是8位乘法，结果默认放在`AX`中；如果是16位乘法，结果**高位**默认在`DX`内存放，**低位`AX`**中存放。

  格式如下：

  ```assembly
  mul reg 
  mul 内存单元
  ```

  

- 模块化程序设计

  本质上就是在使用`call`和`ret`完成整个程序设计并且对于代码一定要有完整的说明，以便于其他人使用

  ```assembly
  ;说明：计算N的3次方
  ;参数：（bx）= N
  ;结果：(dx:ax) = N^3
  
  cube:	mov ax, bx
  		mul bx
  		mul bx
  		ret
  ```

  

- 寄存器冲突问题

  最简洁的方法就是在子程序的开始将子程序中所有用到的寄存器中的内容全部保存起来，在子程序返回前再恢复。可以用栈来保存寄存器中的内容。

  从而编写子程序的标准框架如下：

  ```assembly
  capital:	push cx
  			push si
  			
  change:		mov cl, [si]
  			mov ch, 0
  			jcxz ok
  			and byte ptr [si], 11011111b
  			inc si
  			jmp short change
  			
  ok:			pop si
  			pop cx
  			ret
  ```

  **注意寄存器出栈和入栈的顺序**

